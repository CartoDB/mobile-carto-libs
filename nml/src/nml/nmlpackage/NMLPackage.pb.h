// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NMLPackage.proto

#ifndef PROTOBUF_NMLPackage_2eproto__INCLUDED
#define PROTOBUF_NMLPackage_2eproto__INCLUDED

#include <string>
#include <cstdint>
#include <algorithm>
#include <vector>
#include "protobuf/pbf.hpp"

// @@protoc_insertion_point(includes)

namespace carto {
namespace nml {
class Vector3;
class ColorRGBA;
class Bounds3;
class Matrix4;
class Sampler;
class Texture;
class ColorOrTexture;
class Material;
class Submesh;
class Mesh;
class MeshInstance;
class SubmeshOp;
class SubmeshOpList;
class MeshOp;
class Model;
class ModelLODTreeNode;
class ModelLODTree;

enum Sampler_Filter {
  Sampler_Filter_NEAREST = 1,
  Sampler_Filter_BILINEAR = 2,
  Sampler_Filter_TRILINEAR = 3
};
enum Sampler_WrapMode {
  Sampler_WrapMode_CLAMP = 1,
  Sampler_WrapMode_REPEAT = 2,
  Sampler_WrapMode_MIRROR = 3
};
enum Texture_Format {
  Texture_Format_JPEG = -2,
  Texture_Format_PNG = -1,
  Texture_Format_LUMINANCE8 = 1,
  Texture_Format_RGB8 = 2,
  Texture_Format_RGBA8 = 3,
  Texture_Format_ETC1 = 4,
  Texture_Format_PVRTC = 5,
  Texture_Format_DXTC = 6
};
enum ColorOrTexture_Type {
  ColorOrTexture_Type_COLOR = 1,
  ColorOrTexture_Type_TEXTURE = 2
};
enum Material_Type {
  Material_Type_CONSTANT = 1,
  Material_Type_PREBAKED = 2,
  Material_Type_LAMBERT = 3,
  Material_Type_PHONG = 4,
  Material_Type_BLINN = 5
};
enum Material_Culling {
  Material_Culling_NONE = 1,
  Material_Culling_FRONT = 2,
  Material_Culling_BACK = 3
};
enum Material_OpaqueMode {
  Material_OpaqueMode_OPAQUE = 0,
  Material_OpaqueMode_TRANSPARENT_RGB = 1,
  Material_OpaqueMode_TRANSPARENT_ALPHA = 2
};
enum Submesh_Type {
  Submesh_Type_POINTS = 1,
  Submesh_Type_LINES = 2,
  Submesh_Type_LINE_STRIPS = 3,
  Submesh_Type_TRIANGLES = 4,
  Submesh_Type_TRIANGLE_STRIPS = 5,
  Submesh_Type_TRIANGLE_FANS = 6
};
// ===================================================================

class Vector3 {
public:
  inline Vector3();
  inline explicit Vector3(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Vector3(const Vector3&) = default;
  inline Vector3(Vector3&&) = default;
  inline Vector3& operator = (const Vector3&) = default;
  inline Vector3& operator = (Vector3&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  static const int kXFieldNumber = 1;
  inline bool has_x() const;
  inline float x() const;

  // required float y = 2;
  static const int kYFieldNumber = 2;
  inline bool has_y() const;
  inline float y() const;

  // required float z = 3;
  static const int kZFieldNumber = 3;
  inline bool has_z() const;
  inline float z() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Vector3)
private:
  std::uint32_t _has_bits_[1];
  float x_ = 0;
  float y_ = 0;
  float z_ = 0;
};
// -------------------------------------------------------------------

class ColorRGBA {
public:
  inline ColorRGBA();
  inline explicit ColorRGBA(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline ColorRGBA(const ColorRGBA&) = default;
  inline ColorRGBA(ColorRGBA&&) = default;
  inline ColorRGBA& operator = (const ColorRGBA&) = default;
  inline ColorRGBA& operator = (ColorRGBA&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float r = 1;
  static const int kRFieldNumber = 1;
  inline bool has_r() const;
  inline float r() const;

  // required float g = 2;
  static const int kGFieldNumber = 2;
  inline bool has_g() const;
  inline float g() const;

  // required float b = 3;
  static const int kBFieldNumber = 3;
  inline bool has_b() const;
  inline float b() const;

  // required float a = 4;
  static const int kAFieldNumber = 4;
  inline bool has_a() const;
  inline float a() const;

  // @@protoc_insertion_point(class_scope:carto.nml.ColorRGBA)
private:
  std::uint32_t _has_bits_[1];
  float r_ = 0;
  float g_ = 0;
  float b_ = 0;
  float a_ = 0;
};
// -------------------------------------------------------------------

class Bounds3 {
public:
  inline Bounds3();
  inline explicit Bounds3(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Bounds3(const Bounds3&) = default;
  inline Bounds3(Bounds3&&) = default;
  inline Bounds3& operator = (const Bounds3&) = default;
  inline Bounds3& operator = (Bounds3&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .carto.nml.Vector3 min = 1;
  static const int kMinFieldNumber = 1;
  inline bool has_min() const;
  inline const ::carto::nml::Vector3& min() const;

  // required .carto.nml.Vector3 max = 2;
  static const int kMaxFieldNumber = 2;
  inline bool has_max() const;
  inline const ::carto::nml::Vector3& max() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Bounds3)
private:
  std::uint32_t _has_bits_[1];
  ::carto::nml::Vector3 min_ = ::carto::nml::Vector3();
  ::carto::nml::Vector3 max_ = ::carto::nml::Vector3();
};
// -------------------------------------------------------------------

class Matrix4 {
public:
  inline Matrix4();
  inline explicit Matrix4(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Matrix4(const Matrix4&) = default;
  inline Matrix4(Matrix4&&) = default;
  inline Matrix4& operator = (const Matrix4&) = default;
  inline Matrix4& operator = (Matrix4&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float m00 = 1;
  static const int kM00FieldNumber = 1;
  inline bool has_m00() const;
  inline float m00() const;

  // required float m01 = 2;
  static const int kM01FieldNumber = 2;
  inline bool has_m01() const;
  inline float m01() const;

  // required float m02 = 3;
  static const int kM02FieldNumber = 3;
  inline bool has_m02() const;
  inline float m02() const;

  // required float m03 = 4;
  static const int kM03FieldNumber = 4;
  inline bool has_m03() const;
  inline float m03() const;

  // required float m10 = 5;
  static const int kM10FieldNumber = 5;
  inline bool has_m10() const;
  inline float m10() const;

  // required float m11 = 6;
  static const int kM11FieldNumber = 6;
  inline bool has_m11() const;
  inline float m11() const;

  // required float m12 = 7;
  static const int kM12FieldNumber = 7;
  inline bool has_m12() const;
  inline float m12() const;

  // required float m13 = 8;
  static const int kM13FieldNumber = 8;
  inline bool has_m13() const;
  inline float m13() const;

  // required float m20 = 9;
  static const int kM20FieldNumber = 9;
  inline bool has_m20() const;
  inline float m20() const;

  // required float m21 = 10;
  static const int kM21FieldNumber = 10;
  inline bool has_m21() const;
  inline float m21() const;

  // required float m22 = 11;
  static const int kM22FieldNumber = 11;
  inline bool has_m22() const;
  inline float m22() const;

  // required float m23 = 12;
  static const int kM23FieldNumber = 12;
  inline bool has_m23() const;
  inline float m23() const;

  // required float m30 = 13;
  static const int kM30FieldNumber = 13;
  inline bool has_m30() const;
  inline float m30() const;

  // required float m31 = 14;
  static const int kM31FieldNumber = 14;
  inline bool has_m31() const;
  inline float m31() const;

  // required float m32 = 15;
  static const int kM32FieldNumber = 15;
  inline bool has_m32() const;
  inline float m32() const;

  // required float m33 = 16;
  static const int kM33FieldNumber = 16;
  inline bool has_m33() const;
  inline float m33() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Matrix4)
private:
  std::uint32_t _has_bits_[1];
  float m00_ = 0;
  float m01_ = 0;
  float m02_ = 0;
  float m03_ = 0;
  float m10_ = 0;
  float m11_ = 0;
  float m12_ = 0;
  float m13_ = 0;
  float m20_ = 0;
  float m21_ = 0;
  float m22_ = 0;
  float m23_ = 0;
  float m30_ = 0;
  float m31_ = 0;
  float m32_ = 0;
  float m33_ = 0;
};
// -------------------------------------------------------------------

class Sampler {
public:
  inline Sampler();
  inline explicit Sampler(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Sampler(const Sampler&) = default;
  inline Sampler(Sampler&&) = default;
  inline Sampler& operator = (const Sampler&) = default;
  inline Sampler& operator = (Sampler&&) = default;
  #endif

  // nested types ----------------------------------------------------

  typedef Sampler_Filter Filter;
  static const Filter NEAREST = Sampler_Filter_NEAREST;
  static const Filter BILINEAR = Sampler_Filter_BILINEAR;
  static const Filter TRILINEAR = Sampler_Filter_TRILINEAR;

  typedef Sampler_WrapMode WrapMode;
  static const WrapMode CLAMP = Sampler_WrapMode_CLAMP;
  static const WrapMode REPEAT = Sampler_WrapMode_REPEAT;
  static const WrapMode MIRROR = Sampler_WrapMode_MIRROR;

  // accessors -------------------------------------------------------

  // optional .carto.nml.Sampler.Filter filter = 1;
  static const int kFilterFieldNumber = 1;
  inline bool has_filter() const;
  inline ::carto::nml::Sampler_Filter filter() const;

  // optional .carto.nml.Sampler.WrapMode wrap_s = 2;
  static const int kWrapSFieldNumber = 2;
  inline bool has_wrap_s() const;
  inline ::carto::nml::Sampler_WrapMode wrap_s() const;

  // optional .carto.nml.Sampler.WrapMode wrap_t = 3;
  static const int kWrapTFieldNumber = 3;
  inline bool has_wrap_t() const;
  inline ::carto::nml::Sampler_WrapMode wrap_t() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Sampler)
private:
  std::uint32_t _has_bits_[1];
  int filter_ = 1;
  int wrap_s_ = 1;
  int wrap_t_ = 1;
};
// -------------------------------------------------------------------

class Texture {
public:
  inline Texture();
  inline explicit Texture(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Texture(const Texture&) = default;
  inline Texture(Texture&&) = default;
  inline Texture& operator = (const Texture&) = default;
  inline Texture& operator = (Texture&&) = default;
  #endif

  // nested types ----------------------------------------------------

  typedef Texture_Format Format;
  static const Format JPEG = Texture_Format_JPEG;
  static const Format PNG = Texture_Format_PNG;
  static const Format LUMINANCE8 = Texture_Format_LUMINANCE8;
  static const Format RGB8 = Texture_Format_RGB8;
  static const Format RGBA8 = Texture_Format_RGBA8;
  static const Format ETC1 = Texture_Format_ETC1;
  static const Format PVRTC = Texture_Format_PVRTC;
  static const Format DXTC = Texture_Format_DXTC;

  // accessors -------------------------------------------------------

  // required string id = 1;
  static const int kIdFieldNumber = 1;
  inline bool has_id() const;
  inline const ::std::string& id() const;
  inline void set_id(const std::string& id) { id_ = id; }

  // required .carto.nml.Texture.Format format = 2;
  static const int kFormatFieldNumber = 2;
  inline bool has_format() const;
  inline ::carto::nml::Texture_Format format() const;
  inline void set_format(::carto::nml::Texture_Format format) { format_ = format; }

  // required int32 width = 3;
  static const int kWidthFieldNumber = 3;
  inline bool has_width() const;
  inline std::int32_t width() const;
  inline void set_width(int width) { width_ = width; }

  // required int32 height = 4;
  static const int kHeightFieldNumber = 4;
  inline bool has_height() const;
  inline std::int32_t height() const;
  inline void set_height(int height) { height_ = height; }

  // required .carto.nml.Sampler sampler = 5;
  static const int kSamplerFieldNumber = 5;
  inline bool has_sampler() const;
  inline const ::carto::nml::Sampler& sampler() const;

  // repeated bytes mipmaps = 6;
  static const int kMipmapsFieldNumber = 6;
  inline int mipmaps_size() const;
  inline const ::std::string& mipmaps(int index) const;
  inline const std::vector< ::std::string >& mipmaps() const;
  inline void set_mipmaps(int i, const std::string& data) {
    mipmaps_.resize(std::max(mipmaps_.size(), (std::size_t)(i + 1)));
    mipmaps_[i] = data;
  }
  inline std::string* add_mipmaps() {
    mipmaps_.push_back(std::string());
    return &mipmaps_.back();
  }

  // @@protoc_insertion_point(class_scope:carto.nml.Texture)
private:
  std::uint32_t _has_bits_[1];
  ::std::string id_ = "";
  int format_ = -2;
  std::int32_t width_ = 0;
  ::carto::nml::Sampler sampler_ = ::carto::nml::Sampler();
  std::vector< ::std::string > mipmaps_;
  std::int32_t height_ = 0;
};
// -------------------------------------------------------------------

class ColorOrTexture {
public:
  inline ColorOrTexture();
  inline explicit ColorOrTexture(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline ColorOrTexture(const ColorOrTexture&) = default;
  inline ColorOrTexture(ColorOrTexture&&) = default;
  inline ColorOrTexture& operator = (const ColorOrTexture&) = default;
  inline ColorOrTexture& operator = (ColorOrTexture&&) = default;
  #endif

  // nested types ----------------------------------------------------

  typedef ColorOrTexture_Type Type;
  static const Type COLOR = ColorOrTexture_Type_COLOR;
  static const Type TEXTURE = ColorOrTexture_Type_TEXTURE;

  // accessors -------------------------------------------------------

  // required .carto.nml.ColorOrTexture.Type type = 1;
  static const int kTypeFieldNumber = 1;
  inline bool has_type() const;
  inline ::carto::nml::ColorOrTexture_Type type() const;

  // optional .carto.nml.ColorRGBA color = 2;
  static const int kColorFieldNumber = 2;
  inline bool has_color() const;
  inline const ::carto::nml::ColorRGBA& color() const;

  // optional string texture_id = 3;
  static const int kTextureIdFieldNumber = 3;
  inline bool has_texture_id() const;
  inline const ::std::string& texture_id() const;

  // @@protoc_insertion_point(class_scope:carto.nml.ColorOrTexture)
private:
  std::uint32_t _has_bits_[1];
  ::carto::nml::ColorRGBA color_ = ::carto::nml::ColorRGBA();
  ::std::string texture_id_ = "";
  int type_ = 1;
};
// -------------------------------------------------------------------

class Material {
public:
  inline Material();
  inline explicit Material(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Material(const Material&) = default;
  inline Material(Material&&) = default;
  inline Material& operator = (const Material&) = default;
  inline Material& operator = (Material&&) = default;
  #endif

  // nested types ----------------------------------------------------

  typedef Material_Type Type;
  static const Type CONSTANT = Material_Type_CONSTANT;
  static const Type PREBAKED = Material_Type_PREBAKED;
  static const Type LAMBERT = Material_Type_LAMBERT;
  static const Type PHONG = Material_Type_PHONG;
  static const Type BLINN = Material_Type_BLINN;

  typedef Material_Culling Culling;
  static const Culling NONE = Material_Culling_NONE;
  static const Culling FRONT = Material_Culling_FRONT;
  static const Culling BACK = Material_Culling_BACK;

  typedef Material_OpaqueMode OpaqueMode;
  static const OpaqueMode OPAQUE = Material_OpaqueMode_OPAQUE;
  static const OpaqueMode TRANSPARENT_RGB = Material_OpaqueMode_TRANSPARENT_RGB;
  static const OpaqueMode TRANSPARENT_ALPHA = Material_OpaqueMode_TRANSPARENT_ALPHA;

  // accessors -------------------------------------------------------

  // required string id = 1;
  static const int kIdFieldNumber = 1;
  inline bool has_id() const;
  inline const ::std::string& id() const;

  // required .carto.nml.Material.Type type = 2;
  static const int kTypeFieldNumber = 2;
  inline bool has_type() const;
  inline ::carto::nml::Material_Type type() const;

  // required .carto.nml.Material.Culling culling = 3;
  static const int kCullingFieldNumber = 3;
  inline bool has_culling() const;
  inline ::carto::nml::Material_Culling culling() const;

  // optional .carto.nml.ColorOrTexture emission = 4;
  static const int kEmissionFieldNumber = 4;
  inline bool has_emission() const;
  inline const ::carto::nml::ColorOrTexture& emission() const;

  // optional .carto.nml.ColorOrTexture ambient = 5;
  static const int kAmbientFieldNumber = 5;
  inline bool has_ambient() const;
  inline const ::carto::nml::ColorOrTexture& ambient() const;

  // optional .carto.nml.ColorOrTexture diffuse = 6;
  static const int kDiffuseFieldNumber = 6;
  inline bool has_diffuse() const;
  inline const ::carto::nml::ColorOrTexture& diffuse() const;

  // optional .carto.nml.Material.OpaqueMode opaque_mode = 7;
  static const int kOpaqueModeFieldNumber = 7;
  inline bool has_opaque_mode() const;
  inline ::carto::nml::Material_OpaqueMode opaque_mode() const;

  // optional float transparency = 8;
  static const int kTransparencyFieldNumber = 8;
  inline bool has_transparency() const;
  inline float transparency() const;

  // optional .carto.nml.ColorOrTexture transparent = 9;
  static const int kTransparentFieldNumber = 9;
  inline bool has_transparent() const;
  inline const ::carto::nml::ColorOrTexture& transparent() const;

  // optional float shininess = 10;
  static const int kShininessFieldNumber = 10;
  inline bool has_shininess() const;
  inline float shininess() const;

  // optional .carto.nml.ColorOrTexture specular = 11;
  static const int kSpecularFieldNumber = 11;
  inline bool has_specular() const;
  inline const ::carto::nml::ColorOrTexture& specular() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Material)
private:
  std::uint32_t _has_bits_[1];
  ::std::string id_ = "";
  int type_ = 1;
  int culling_ = 1;
  ::carto::nml::ColorOrTexture emission_ = ::carto::nml::ColorOrTexture();
  ::carto::nml::ColorOrTexture ambient_ = ::carto::nml::ColorOrTexture();
  ::carto::nml::ColorOrTexture diffuse_ = ::carto::nml::ColorOrTexture();
  int opaque_mode_ = 0;
  float transparency_ = 0;
  ::carto::nml::ColorOrTexture transparent_ = ::carto::nml::ColorOrTexture();
  ::carto::nml::ColorOrTexture specular_ = ::carto::nml::ColorOrTexture();
  float shininess_ = 0;
};
// -------------------------------------------------------------------

class Submesh {
public:
  inline Submesh();
  inline explicit Submesh(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Submesh(const Submesh&) = default;
  inline Submesh(Submesh&&) = default;
  inline Submesh& operator = (const Submesh&) = default;
  inline Submesh& operator = (Submesh&&) = default;
  #endif

  // nested types ----------------------------------------------------

  typedef Submesh_Type Type;
  static const Type POINTS = Submesh_Type_POINTS;
  static const Type LINES = Submesh_Type_LINES;
  static const Type LINE_STRIPS = Submesh_Type_LINE_STRIPS;
  static const Type TRIANGLES = Submesh_Type_TRIANGLES;
  static const Type TRIANGLE_STRIPS = Submesh_Type_TRIANGLE_STRIPS;
  static const Type TRIANGLE_FANS = Submesh_Type_TRIANGLE_FANS;

  // accessors -------------------------------------------------------

  // required .carto.nml.Submesh.Type type = 1;
  static const int kTypeFieldNumber = 1;
  inline bool has_type() const;
  inline ::carto::nml::Submesh_Type type() const;

  // required string material_id = 2;
  static const int kMaterialIdFieldNumber = 2;
  inline bool has_material_id() const;
  inline const ::std::string& material_id() const;

  // repeated int32 vertex_counts = 3;
  static const int kVertexCountsFieldNumber = 3;
  inline int vertex_counts_size() const;
  inline std::int32_t vertex_counts(int index) const;
  inline const std::vector< std::int32_t >& vertex_counts() const;

  // required bytes positions = 4;
  static const int kPositionsFieldNumber = 4;
  inline bool has_positions() const;
  inline const ::std::string& positions() const;

  // optional bytes normals = 5;
  static const int kNormalsFieldNumber = 5;
  inline bool has_normals() const;
  inline const ::std::string& normals() const;

  // optional bytes uvs = 6;
  static const int kUvsFieldNumber = 6;
  inline bool has_uvs() const;
  inline const ::std::string& uvs() const;

  // optional bytes colors = 7;
  static const int kColorsFieldNumber = 7;
  inline bool has_colors() const;
  inline const ::std::string& colors() const;

  // repeated int64 vertex_ids = 8;
  static const int kVertexIdsFieldNumber = 8;
  inline int vertex_ids_size() const;
  inline std::int64_t vertex_ids(int index) const;
  inline const std::vector< std::int64_t >& vertex_ids() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Submesh)
private:
  std::uint32_t _has_bits_[1];
  ::std::string material_id_ = "";
  std::vector< std::int32_t > vertex_counts_;
  ::std::string positions_ = "";
  ::std::string normals_ = "";
  ::std::string uvs_ = "";
  ::std::string colors_ = "";
  std::vector< std::int64_t > vertex_ids_;
  int type_ = 1;
};
// -------------------------------------------------------------------

class Mesh {
public:
  inline Mesh();
  inline explicit Mesh(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Mesh(const Mesh&) = default;
  inline Mesh(Mesh&&) = default;
  inline Mesh& operator = (const Mesh&) = default;
  inline Mesh& operator = (Mesh&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  static const int kIdFieldNumber = 1;
  inline bool has_id() const;
  inline const ::std::string& id() const;

  // required .carto.nml.Bounds3 bounds = 2;
  static const int kBoundsFieldNumber = 2;
  inline bool has_bounds() const;
  inline const ::carto::nml::Bounds3& bounds() const;

  // repeated .carto.nml.Submesh submeshes = 3;
  static const int kSubmeshesFieldNumber = 3;
  inline int submeshes_size() const;
  inline const ::carto::nml::Submesh& submeshes(int index) const;
  inline const std::vector< ::carto::nml::Submesh >& submeshes() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Mesh)
private:
  std::uint32_t _has_bits_[1];
  ::std::string id_ = "";
  ::carto::nml::Bounds3 bounds_ = ::carto::nml::Bounds3();
  std::vector< ::carto::nml::Submesh > submeshes_;
};
// -------------------------------------------------------------------

class MeshInstance {
public:
  inline MeshInstance();
  inline explicit MeshInstance(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline MeshInstance(const MeshInstance&) = default;
  inline MeshInstance(MeshInstance&&) = default;
  inline MeshInstance& operator = (const MeshInstance&) = default;
  inline MeshInstance& operator = (MeshInstance&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string mesh_id = 1;
  static const int kMeshIdFieldNumber = 1;
  inline bool has_mesh_id() const;
  inline const ::std::string& mesh_id() const;

  // repeated .carto.nml.Material materials = 2;
  static const int kMaterialsFieldNumber = 2;
  inline int materials_size() const;
  inline const ::carto::nml::Material& materials(int index) const;
  inline const std::vector< ::carto::nml::Material >& materials() const;

  // optional .carto.nml.Matrix4 transform = 3;
  static const int kTransformFieldNumber = 3;
  inline bool has_transform() const;
  inline const ::carto::nml::Matrix4& transform() const;

  // @@protoc_insertion_point(class_scope:carto.nml.MeshInstance)
private:
  std::uint32_t _has_bits_[1];
  ::std::string mesh_id_ = "";
  std::vector< ::carto::nml::Material > materials_;
  ::carto::nml::Matrix4 transform_ = ::carto::nml::Matrix4();
};
// -------------------------------------------------------------------

class SubmeshOp {
public:
  inline SubmeshOp();
  inline explicit SubmeshOp(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline SubmeshOp(const SubmeshOp&) = default;
  inline SubmeshOp(SubmeshOp&&) = default;
  inline SubmeshOp& operator = (const SubmeshOp&) = default;
  inline SubmeshOp& operator = (SubmeshOp&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 submesh_idx = 1;
  static const int kSubmeshIdxFieldNumber = 1;
  inline bool has_submesh_idx() const;
  inline std::int32_t submesh_idx() const;

  // required int32 offset = 2;
  static const int kOffsetFieldNumber = 2;
  inline bool has_offset() const;
  inline std::int32_t offset() const;

  // required int32 count = 3;
  static const int kCountFieldNumber = 3;
  inline bool has_count() const;
  inline std::int32_t count() const;

  // required float tex_u_scale = 4;
  static const int kTexUScaleFieldNumber = 4;
  inline bool has_tex_u_scale() const;
  inline float tex_u_scale() const;

  // required float tex_v_scale = 5;
  static const int kTexVScaleFieldNumber = 5;
  inline bool has_tex_v_scale() const;
  inline float tex_v_scale() const;

  // required float tex_u_trans = 6;
  static const int kTexUTransFieldNumber = 6;
  inline bool has_tex_u_trans() const;
  inline float tex_u_trans() const;

  // required float tex_v_trans = 7;
  static const int kTexVTransFieldNumber = 7;
  inline bool has_tex_v_trans() const;
  inline float tex_v_trans() const;

  // @@protoc_insertion_point(class_scope:carto.nml.SubmeshOp)
private:
  std::uint32_t _has_bits_[1];
  std::int32_t submesh_idx_ = 0;
  std::int32_t offset_ = 0;
  std::int32_t count_ = 0;
  float tex_u_scale_ = 0;
  float tex_v_scale_ = 0;
  float tex_u_trans_ = 0;
  float tex_v_trans_ = 0;
};
// -------------------------------------------------------------------

class SubmeshOpList {
public:
  inline SubmeshOpList();
  inline explicit SubmeshOpList(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline SubmeshOpList(const SubmeshOpList&) = default;
  inline SubmeshOpList(SubmeshOpList&&) = default;
  inline SubmeshOpList& operator = (const SubmeshOpList&) = default;
  inline SubmeshOpList& operator = (SubmeshOpList&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .carto.nml.Submesh.Type type = 1;
  static const int kTypeFieldNumber = 1;
  inline bool has_type() const;
  inline ::carto::nml::Submesh_Type type() const;

  // required string material_id = 2;
  static const int kMaterialIdFieldNumber = 2;
  inline bool has_material_id() const;
  inline const ::std::string& material_id() const;

  // repeated .carto.nml.SubmeshOp submesh_ops = 3;
  static const int kSubmeshOpsFieldNumber = 3;
  inline int submesh_ops_size() const;
  inline const ::carto::nml::SubmeshOp& submesh_ops(int index) const;
  inline const std::vector< ::carto::nml::SubmeshOp >& submesh_ops() const;

  // @@protoc_insertion_point(class_scope:carto.nml.SubmeshOpList)
private:
  std::uint32_t _has_bits_[1];
  ::std::string material_id_ = "";
  std::vector< ::carto::nml::SubmeshOp > submesh_ops_;
  int type_ = 1;
};
// -------------------------------------------------------------------

class MeshOp {
public:
  inline MeshOp();
  inline explicit MeshOp(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline MeshOp(const MeshOp&) = default;
  inline MeshOp(MeshOp&&) = default;
  inline MeshOp& operator = (const MeshOp&) = default;
  inline MeshOp& operator = (MeshOp&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  static const int kIdFieldNumber = 1;
  inline bool has_id() const;
  inline const ::std::string& id() const;

  // required .carto.nml.Bounds3 bounds = 2;
  static const int kBoundsFieldNumber = 2;
  inline bool has_bounds() const;
  inline const ::carto::nml::Bounds3& bounds() const;

  // repeated .carto.nml.SubmeshOpList submesh_op_lists = 3;
  static const int kSubmeshOpListsFieldNumber = 3;
  inline int submesh_op_lists_size() const;
  inline const ::carto::nml::SubmeshOpList& submesh_op_lists(int index) const;
  inline const std::vector< ::carto::nml::SubmeshOpList >& submesh_op_lists() const;

  // @@protoc_insertion_point(class_scope:carto.nml.MeshOp)
private:
  std::uint32_t _has_bits_[1];
  ::std::string id_ = "";
  ::carto::nml::Bounds3 bounds_ = ::carto::nml::Bounds3();
  std::vector< ::carto::nml::SubmeshOpList > submesh_op_lists_;
};
// -------------------------------------------------------------------

class Model {
public:
  inline Model();
  inline explicit Model(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline Model(const Model&) = default;
  inline Model(Model&&) = default;
  inline Model& operator = (const Model&) = default;
  inline Model& operator = (Model&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string id = 1;
  static const int kIdFieldNumber = 1;
  inline bool has_id() const;
  inline const ::std::string& id() const;

  // repeated .carto.nml.MeshInstance mesh_instances = 2;
  static const int kMeshInstancesFieldNumber = 2;
  inline int mesh_instances_size() const;
  inline const ::carto::nml::MeshInstance& mesh_instances(int index) const;
  inline const std::vector< ::carto::nml::MeshInstance >& mesh_instances() const;

  // repeated .carto.nml.Mesh meshes = 3;
  static const int kMeshesFieldNumber = 3;
  inline int meshes_size() const;
  inline const ::carto::nml::Mesh& meshes(int index) const;
  inline const std::vector< ::carto::nml::Mesh >& meshes() const;

  // repeated .carto.nml.Texture textures = 4;
  static const int kTexturesFieldNumber = 4;
  inline int textures_size() const;
  inline const ::carto::nml::Texture& textures(int index) const;
  inline const std::vector< ::carto::nml::Texture >& textures() const;

  // required .carto.nml.Bounds3 bounds = 5;
  static const int kBoundsFieldNumber = 5;
  inline bool has_bounds() const;
  inline const ::carto::nml::Bounds3& bounds() const;

  // required int32 mesh_footprint = 6;
  static const int kMeshFootprintFieldNumber = 6;
  inline bool has_mesh_footprint() const;
  inline std::int32_t mesh_footprint() const;

  // required int32 texture_footprint = 7;
  static const int kTextureFootprintFieldNumber = 7;
  inline bool has_texture_footprint() const;
  inline std::int32_t texture_footprint() const;

  // @@protoc_insertion_point(class_scope:carto.nml.Model)
private:
  std::uint32_t _has_bits_[1];
  ::std::string id_ = "";
  std::vector< ::carto::nml::MeshInstance > mesh_instances_;
  std::vector< ::carto::nml::Mesh > meshes_;
  std::vector< ::carto::nml::Texture > textures_;
  ::carto::nml::Bounds3 bounds_ = ::carto::nml::Bounds3();
  std::int32_t mesh_footprint_ = 0;
  std::int32_t texture_footprint_ = 0;
};
// -------------------------------------------------------------------

class ModelLODTreeNode {
public:
  inline ModelLODTreeNode();
  inline explicit ModelLODTreeNode(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline ModelLODTreeNode(const ModelLODTreeNode&) = default;
  inline ModelLODTreeNode(ModelLODTreeNode&&) = default;
  inline ModelLODTreeNode& operator = (const ModelLODTreeNode&) = default;
  inline ModelLODTreeNode& operator = (ModelLODTreeNode&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  static const int kIdFieldNumber = 1;
  inline bool has_id() const;
  inline std::int32_t id() const;

  // required .carto.nml.Bounds3 bounds = 2;
  static const int kBoundsFieldNumber = 2;
  inline bool has_bounds() const;
  inline const ::carto::nml::Bounds3& bounds() const;

  // required .carto.nml.Model model = 3;
  static const int kModelFieldNumber = 3;
  inline bool has_model() const;
  inline const ::carto::nml::Model& model() const;

  // repeated int32 children_ids = 4;
  static const int kChildrenIdsFieldNumber = 4;
  inline int children_ids_size() const;
  inline std::int32_t children_ids(int index) const;
  inline const std::vector< std::int32_t >& children_ids() const;

  // @@protoc_insertion_point(class_scope:carto.nml.ModelLODTreeNode)
private:
  std::uint32_t _has_bits_[1];
  ::carto::nml::Bounds3 bounds_ = ::carto::nml::Bounds3();
  ::carto::nml::Model model_ = ::carto::nml::Model();
  std::vector< std::int32_t > children_ids_;
  std::int32_t id_ = 0;
};
// -------------------------------------------------------------------

class ModelLODTree {
public:
  inline ModelLODTree();
  inline explicit ModelLODTree(const protobuf::message& srcMsg);
  #if _PROTOBUF_USE_RVALUE_REFS
  inline ModelLODTree(const ModelLODTree&) = default;
  inline ModelLODTree(ModelLODTree&&) = default;
  inline ModelLODTree& operator = (const ModelLODTree&) = default;
  inline ModelLODTree& operator = (ModelLODTree&&) = default;
  #endif

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .carto.nml.ModelLODTreeNode nodes = 1;
  static const int kNodesFieldNumber = 1;
  inline int nodes_size() const;
  inline const ::carto::nml::ModelLODTreeNode& nodes(int index) const;
  inline const std::vector< ::carto::nml::ModelLODTreeNode >& nodes() const;

  // @@protoc_insertion_point(class_scope:carto.nml.ModelLODTree)
private:
  std::uint32_t _has_bits_[1];
  std::vector< ::carto::nml::ModelLODTreeNode > nodes_;
};
// ===================================================================

// Vector3

inline Vector3::Vector3() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Vector3::Vector3(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kXFieldNumber) {
      x_ = msg.read_float();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kYFieldNumber) {
      y_ = msg.read_float();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kZFieldNumber) {
      z_ = msg.read_float();
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// required float x = 1;
inline bool Vector3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline float Vector3::x() const {
  // @@protoc_insertion_point(field_get:carto.nml.Vector3.x)
  return x_;
}

// required float y = 2;
inline bool Vector3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline float Vector3::y() const {
  // @@protoc_insertion_point(field_get:carto.nml.Vector3.y)
  return y_;
}

// required float z = 3;
inline bool Vector3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline float Vector3::z() const {
  // @@protoc_insertion_point(field_get:carto.nml.Vector3.z)
  return z_;
}

// -------------------------------------------------------------------

// ColorRGBA

inline ColorRGBA::ColorRGBA() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline ColorRGBA::ColorRGBA(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kRFieldNumber) {
      r_ = msg.read_float();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kGFieldNumber) {
      g_ = msg.read_float();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kBFieldNumber) {
      b_ = msg.read_float();
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kAFieldNumber) {
      a_ = msg.read_float();
      _has_bits_[0] |= 0x00000008u;
    }
    else msg.skip();
  }
}

// required float r = 1;
inline bool ColorRGBA::has_r() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline float ColorRGBA::r() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorRGBA.r)
  return r_;
}

// required float g = 2;
inline bool ColorRGBA::has_g() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline float ColorRGBA::g() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorRGBA.g)
  return g_;
}

// required float b = 3;
inline bool ColorRGBA::has_b() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline float ColorRGBA::b() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorRGBA.b)
  return b_;
}

// required float a = 4;
inline bool ColorRGBA::has_a() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}

inline float ColorRGBA::a() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorRGBA.a)
  return a_;
}

// -------------------------------------------------------------------

// Bounds3

inline Bounds3::Bounds3() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Bounds3::Bounds3(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kMinFieldNumber) {
      min_ = ::carto::nml::Vector3(msg.read_message());
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kMaxFieldNumber) {
      max_ = ::carto::nml::Vector3(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else msg.skip();
  }
}

// required .carto.nml.Vector3 min = 1;
inline bool Bounds3::has_min() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::carto::nml::Vector3& Bounds3::min() const {
  // @@protoc_insertion_point(field_get:carto.nml.Bounds3.min)
  return min_;
}

// required .carto.nml.Vector3 max = 2;
inline bool Bounds3::has_max() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::carto::nml::Vector3& Bounds3::max() const {
  // @@protoc_insertion_point(field_get:carto.nml.Bounds3.max)
  return max_;
}

// -------------------------------------------------------------------

// Matrix4

inline Matrix4::Matrix4() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Matrix4::Matrix4(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kM00FieldNumber) {
      m00_ = msg.read_float();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kM01FieldNumber) {
      m01_ = msg.read_float();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kM02FieldNumber) {
      m02_ = msg.read_float();
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kM03FieldNumber) {
      m03_ = msg.read_float();
      _has_bits_[0] |= 0x00000008u;
    }
    else if (msg.tag == kM10FieldNumber) {
      m10_ = msg.read_float();
      _has_bits_[0] |= 0x00000010u;
    }
    else if (msg.tag == kM11FieldNumber) {
      m11_ = msg.read_float();
      _has_bits_[0] |= 0x00000020u;
    }
    else if (msg.tag == kM12FieldNumber) {
      m12_ = msg.read_float();
      _has_bits_[0] |= 0x00000040u;
    }
    else if (msg.tag == kM13FieldNumber) {
      m13_ = msg.read_float();
      _has_bits_[0] |= 0x00000080u;
    }
    else if (msg.tag == kM20FieldNumber) {
      m20_ = msg.read_float();
      _has_bits_[0] |= 0x00000100u;
    }
    else if (msg.tag == kM21FieldNumber) {
      m21_ = msg.read_float();
      _has_bits_[0] |= 0x00000200u;
    }
    else if (msg.tag == kM22FieldNumber) {
      m22_ = msg.read_float();
      _has_bits_[0] |= 0x00000400u;
    }
    else if (msg.tag == kM23FieldNumber) {
      m23_ = msg.read_float();
      _has_bits_[0] |= 0x00000800u;
    }
    else if (msg.tag == kM30FieldNumber) {
      m30_ = msg.read_float();
      _has_bits_[0] |= 0x00001000u;
    }
    else if (msg.tag == kM31FieldNumber) {
      m31_ = msg.read_float();
      _has_bits_[0] |= 0x00002000u;
    }
    else if (msg.tag == kM32FieldNumber) {
      m32_ = msg.read_float();
      _has_bits_[0] |= 0x00004000u;
    }
    else if (msg.tag == kM33FieldNumber) {
      m33_ = msg.read_float();
      _has_bits_[0] |= 0x00008000u;
    }
    else msg.skip();
  }
}

// required float m00 = 1;
inline bool Matrix4::has_m00() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline float Matrix4::m00() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m00)
  return m00_;
}

// required float m01 = 2;
inline bool Matrix4::has_m01() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline float Matrix4::m01() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m01)
  return m01_;
}

// required float m02 = 3;
inline bool Matrix4::has_m02() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline float Matrix4::m02() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m02)
  return m02_;
}

// required float m03 = 4;
inline bool Matrix4::has_m03() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}

inline float Matrix4::m03() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m03)
  return m03_;
}

// required float m10 = 5;
inline bool Matrix4::has_m10() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}

inline float Matrix4::m10() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m10)
  return m10_;
}

// required float m11 = 6;
inline bool Matrix4::has_m11() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}

inline float Matrix4::m11() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m11)
  return m11_;
}

// required float m12 = 7;
inline bool Matrix4::has_m12() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}

inline float Matrix4::m12() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m12)
  return m12_;
}

// required float m13 = 8;
inline bool Matrix4::has_m13() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}

inline float Matrix4::m13() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m13)
  return m13_;
}

// required float m20 = 9;
inline bool Matrix4::has_m20() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}

inline float Matrix4::m20() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m20)
  return m20_;
}

// required float m21 = 10;
inline bool Matrix4::has_m21() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}

inline float Matrix4::m21() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m21)
  return m21_;
}

// required float m22 = 11;
inline bool Matrix4::has_m22() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}

inline float Matrix4::m22() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m22)
  return m22_;
}

// required float m23 = 12;
inline bool Matrix4::has_m23() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}

inline float Matrix4::m23() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m23)
  return m23_;
}

// required float m30 = 13;
inline bool Matrix4::has_m30() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}

inline float Matrix4::m30() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m30)
  return m30_;
}

// required float m31 = 14;
inline bool Matrix4::has_m31() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}

inline float Matrix4::m31() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m31)
  return m31_;
}

// required float m32 = 15;
inline bool Matrix4::has_m32() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}

inline float Matrix4::m32() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m32)
  return m32_;
}

// required float m33 = 16;
inline bool Matrix4::has_m33() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}

inline float Matrix4::m33() const {
  // @@protoc_insertion_point(field_get:carto.nml.Matrix4.m33)
  return m33_;
}

// -------------------------------------------------------------------

// Sampler

inline Sampler::Sampler() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Sampler::Sampler(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kFilterFieldNumber) {
      filter_ = msg.read_int32();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kWrapSFieldNumber) {
      wrap_s_ = msg.read_int32();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kWrapTFieldNumber) {
      wrap_t_ = msg.read_int32();
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// optional .carto.nml.Sampler.Filter filter = 1;
inline bool Sampler::has_filter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline ::carto::nml::Sampler_Filter Sampler::filter() const {
  // @@protoc_insertion_point(field_get:carto.nml.Sampler.filter)
  return static_cast< ::carto::nml::Sampler_Filter >(filter_);
}

// optional .carto.nml.Sampler.WrapMode wrap_s = 2;
inline bool Sampler::has_wrap_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline ::carto::nml::Sampler_WrapMode Sampler::wrap_s() const {
  // @@protoc_insertion_point(field_get:carto.nml.Sampler.wrap_s)
  return static_cast< ::carto::nml::Sampler_WrapMode >(wrap_s_);
}

// optional .carto.nml.Sampler.WrapMode wrap_t = 3;
inline bool Sampler::has_wrap_t() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline ::carto::nml::Sampler_WrapMode Sampler::wrap_t() const {
  // @@protoc_insertion_point(field_get:carto.nml.Sampler.wrap_t)
  return static_cast< ::carto::nml::Sampler_WrapMode >(wrap_t_);
}

// -------------------------------------------------------------------

// Texture

inline Texture::Texture() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Texture::Texture(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kFormatFieldNumber) {
      format_ = msg.read_int32();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kWidthFieldNumber) {
      width_ = msg.read_int32();
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kHeightFieldNumber) {
      height_ = msg.read_int32();
      _has_bits_[0] |= 0x00000008u;
    }
    else if (msg.tag == kSamplerFieldNumber) {
      sampler_ = ::carto::nml::Sampler(msg.read_message());
      _has_bits_[0] |= 0x00000010u;
    }
    else if (msg.tag == kMipmapsFieldNumber) {
      mipmaps_.emplace_back(msg.read_bytes());
      _has_bits_[0] |= 0x00000020u;
    }
    else msg.skip();
  }
}

// required string id = 1;
inline bool Texture::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& Texture::id() const {
  // @@protoc_insertion_point(field_get:carto.nml.Texture.id)
  return id_;
}

// required .carto.nml.Texture.Format format = 2;
inline bool Texture::has_format() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline ::carto::nml::Texture_Format Texture::format() const {
  // @@protoc_insertion_point(field_get:carto.nml.Texture.format)
  return static_cast< ::carto::nml::Texture_Format >(format_);
}

// required int32 width = 3;
inline bool Texture::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline std::int32_t Texture::width() const {
  // @@protoc_insertion_point(field_get:carto.nml.Texture.width)
  return width_;
}

// required int32 height = 4;
inline bool Texture::has_height() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}

inline std::int32_t Texture::height() const {
  // @@protoc_insertion_point(field_get:carto.nml.Texture.height)
  return height_;
}

// required .carto.nml.Sampler sampler = 5;
inline bool Texture::has_sampler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}

inline const ::carto::nml::Sampler& Texture::sampler() const {
  // @@protoc_insertion_point(field_get:carto.nml.Texture.sampler)
  return sampler_;
}

// repeated bytes mipmaps = 6;
inline int Texture::mipmaps_size() const {
  return static_cast<int>(mipmaps_.size());
}

inline const ::std::string& Texture::mipmaps(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Texture.mipmaps)
  return mipmaps_[index];
}
inline const std::vector< ::std::string>& Texture::mipmaps() const {
  // @@protoc_insertion_point(field_list:carto.nml.Texture.mipmaps)
  return mipmaps_;
}

// -------------------------------------------------------------------

// ColorOrTexture

inline ColorOrTexture::ColorOrTexture() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline ColorOrTexture::ColorOrTexture(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kTypeFieldNumber) {
      type_ = msg.read_int32();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kColorFieldNumber) {
      color_ = ::carto::nml::ColorRGBA(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kTextureIdFieldNumber) {
      texture_id_ = msg.read_string();
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// required .carto.nml.ColorOrTexture.Type type = 1;
inline bool ColorOrTexture::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline ::carto::nml::ColorOrTexture_Type ColorOrTexture::type() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorOrTexture.type)
  return static_cast< ::carto::nml::ColorOrTexture_Type >(type_);
}

// optional .carto.nml.ColorRGBA color = 2;
inline bool ColorOrTexture::has_color() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::carto::nml::ColorRGBA& ColorOrTexture::color() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorOrTexture.color)
  return color_;
}

// optional string texture_id = 3;
inline bool ColorOrTexture::has_texture_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline const ::std::string& ColorOrTexture::texture_id() const {
  // @@protoc_insertion_point(field_get:carto.nml.ColorOrTexture.texture_id)
  return texture_id_;
}

// -------------------------------------------------------------------

// Material

inline Material::Material() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Material::Material(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kTypeFieldNumber) {
      type_ = msg.read_int32();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kCullingFieldNumber) {
      culling_ = msg.read_int32();
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kEmissionFieldNumber) {
      emission_ = ::carto::nml::ColorOrTexture(msg.read_message());
      _has_bits_[0] |= 0x00000008u;
    }
    else if (msg.tag == kAmbientFieldNumber) {
      ambient_ = ::carto::nml::ColorOrTexture(msg.read_message());
      _has_bits_[0] |= 0x00000010u;
    }
    else if (msg.tag == kDiffuseFieldNumber) {
      diffuse_ = ::carto::nml::ColorOrTexture(msg.read_message());
      _has_bits_[0] |= 0x00000020u;
    }
    else if (msg.tag == kOpaqueModeFieldNumber) {
      opaque_mode_ = msg.read_int32();
      _has_bits_[0] |= 0x00000040u;
    }
    else if (msg.tag == kTransparencyFieldNumber) {
      transparency_ = msg.read_float();
      _has_bits_[0] |= 0x00000080u;
    }
    else if (msg.tag == kTransparentFieldNumber) {
      transparent_ = ::carto::nml::ColorOrTexture(msg.read_message());
      _has_bits_[0] |= 0x00000100u;
    }
    else if (msg.tag == kShininessFieldNumber) {
      shininess_ = msg.read_float();
      _has_bits_[0] |= 0x00000200u;
    }
    else if (msg.tag == kSpecularFieldNumber) {
      specular_ = ::carto::nml::ColorOrTexture(msg.read_message());
      _has_bits_[0] |= 0x00000400u;
    }
    else msg.skip();
  }
}

// required string id = 1;
inline bool Material::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& Material::id() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.id)
  return id_;
}

// required .carto.nml.Material.Type type = 2;
inline bool Material::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline ::carto::nml::Material_Type Material::type() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.type)
  return static_cast< ::carto::nml::Material_Type >(type_);
}

// required .carto.nml.Material.Culling culling = 3;
inline bool Material::has_culling() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline ::carto::nml::Material_Culling Material::culling() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.culling)
  return static_cast< ::carto::nml::Material_Culling >(culling_);
}

// optional .carto.nml.ColorOrTexture emission = 4;
inline bool Material::has_emission() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}

inline const ::carto::nml::ColorOrTexture& Material::emission() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.emission)
  return emission_;
}

// optional .carto.nml.ColorOrTexture ambient = 5;
inline bool Material::has_ambient() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}

inline const ::carto::nml::ColorOrTexture& Material::ambient() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.ambient)
  return ambient_;
}

// optional .carto.nml.ColorOrTexture diffuse = 6;
inline bool Material::has_diffuse() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}

inline const ::carto::nml::ColorOrTexture& Material::diffuse() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.diffuse)
  return diffuse_;
}

// optional .carto.nml.Material.OpaqueMode opaque_mode = 7;
inline bool Material::has_opaque_mode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}

inline ::carto::nml::Material_OpaqueMode Material::opaque_mode() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.opaque_mode)
  return static_cast< ::carto::nml::Material_OpaqueMode >(opaque_mode_);
}

// optional float transparency = 8;
inline bool Material::has_transparency() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}

inline float Material::transparency() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.transparency)
  return transparency_;
}

// optional .carto.nml.ColorOrTexture transparent = 9;
inline bool Material::has_transparent() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}

inline const ::carto::nml::ColorOrTexture& Material::transparent() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.transparent)
  return transparent_;
}

// optional float shininess = 10;
inline bool Material::has_shininess() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}

inline float Material::shininess() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.shininess)
  return shininess_;
}

// optional .carto.nml.ColorOrTexture specular = 11;
inline bool Material::has_specular() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}

inline const ::carto::nml::ColorOrTexture& Material::specular() const {
  // @@protoc_insertion_point(field_get:carto.nml.Material.specular)
  return specular_;
}

// -------------------------------------------------------------------

// Submesh

inline Submesh::Submesh() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Submesh::Submesh(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kTypeFieldNumber) {
      type_ = msg.read_int32();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kMaterialIdFieldNumber) {
      material_id_ = msg.read_string();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kVertexCountsFieldNumber) {
      vertex_counts_.emplace_back(msg.read_int32());
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kPositionsFieldNumber) {
      positions_ = msg.read_bytes();
      _has_bits_[0] |= 0x00000008u;
    }
    else if (msg.tag == kNormalsFieldNumber) {
      normals_ = msg.read_bytes();
      _has_bits_[0] |= 0x00000010u;
    }
    else if (msg.tag == kUvsFieldNumber) {
      uvs_ = msg.read_bytes();
      _has_bits_[0] |= 0x00000020u;
    }
    else if (msg.tag == kColorsFieldNumber) {
      colors_ = msg.read_bytes();
      _has_bits_[0] |= 0x00000040u;
    }
    else if (msg.tag == kVertexIdsFieldNumber) {
      vertex_ids_.emplace_back(msg.read_int64());
      _has_bits_[0] |= 0x00000080u;
    }
    else msg.skip();
  }
}

// required .carto.nml.Submesh.Type type = 1;
inline bool Submesh::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline ::carto::nml::Submesh_Type Submesh::type() const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.type)
  return static_cast< ::carto::nml::Submesh_Type >(type_);
}

// required string material_id = 2;
inline bool Submesh::has_material_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::std::string& Submesh::material_id() const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.material_id)
  return material_id_;
}

// repeated int32 vertex_counts = 3;
inline int Submesh::vertex_counts_size() const {
  return static_cast<int>(vertex_counts_.size());
}

inline std::int32_t Submesh::vertex_counts(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.vertex_counts)
  return vertex_counts_[index];
}

inline const std::vector< std::int32_t >& Submesh::vertex_counts() const {
  // @@protoc_insertion_point(field_list:carto.nml.Submesh.vertex_counts)
  return vertex_counts_;
}

// required bytes positions = 4;
inline bool Submesh::has_positions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}

inline const ::std::string& Submesh::positions() const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.positions)
  return positions_;
}

// optional bytes normals = 5;
inline bool Submesh::has_normals() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}

inline const ::std::string& Submesh::normals() const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.normals)
  return normals_;
}

// optional bytes uvs = 6;
inline bool Submesh::has_uvs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}

inline const ::std::string& Submesh::uvs() const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.uvs)
  return uvs_;
}

// optional bytes colors = 7;
inline bool Submesh::has_colors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}

inline const ::std::string& Submesh::colors() const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.colors)
  return colors_;
}

// repeated int64 vertex_ids = 8;
inline int Submesh::vertex_ids_size() const {
  return static_cast<int>(vertex_ids_.size());
}

inline std::int64_t Submesh::vertex_ids(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Submesh.vertex_ids)
  return vertex_ids_[index];
}

inline const std::vector< std::int64_t >& Submesh::vertex_ids() const {
  // @@protoc_insertion_point(field_list:carto.nml.Submesh.vertex_ids)
  return vertex_ids_;
}

// -------------------------------------------------------------------

// Mesh

inline Mesh::Mesh() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Mesh::Mesh(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kBoundsFieldNumber) {
      bounds_ = ::carto::nml::Bounds3(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kSubmeshesFieldNumber) {
      submeshes_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// required string id = 1;
inline bool Mesh::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& Mesh::id() const {
  // @@protoc_insertion_point(field_get:carto.nml.Mesh.id)
  return id_;
}

// required .carto.nml.Bounds3 bounds = 2;
inline bool Mesh::has_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::carto::nml::Bounds3& Mesh::bounds() const {
  // @@protoc_insertion_point(field_get:carto.nml.Mesh.bounds)
  return bounds_;
}

// repeated .carto.nml.Submesh submeshes = 3;
inline int Mesh::submeshes_size() const {
  return static_cast<int>(submeshes_.size());
}

inline const ::carto::nml::Submesh& Mesh::submeshes(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Mesh.submeshes)
  return submeshes_[index];
}
inline const std::vector< ::carto::nml::Submesh >& Mesh::submeshes() const {
  // @@protoc_insertion_point(field_list:carto.nml.Mesh.submeshes)
  return submeshes_;
}

// -------------------------------------------------------------------

// MeshInstance

inline MeshInstance::MeshInstance() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline MeshInstance::MeshInstance(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kMeshIdFieldNumber) {
      mesh_id_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kMaterialsFieldNumber) {
      materials_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kTransformFieldNumber) {
      transform_ = ::carto::nml::Matrix4(msg.read_message());
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// required string mesh_id = 1;
inline bool MeshInstance::has_mesh_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& MeshInstance::mesh_id() const {
  // @@protoc_insertion_point(field_get:carto.nml.MeshInstance.mesh_id)
  return mesh_id_;
}

// repeated .carto.nml.Material materials = 2;
inline int MeshInstance::materials_size() const {
  return static_cast<int>(materials_.size());
}

inline const ::carto::nml::Material& MeshInstance::materials(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.MeshInstance.materials)
  return materials_[index];
}
inline const std::vector< ::carto::nml::Material >& MeshInstance::materials() const {
  // @@protoc_insertion_point(field_list:carto.nml.MeshInstance.materials)
  return materials_;
}

// optional .carto.nml.Matrix4 transform = 3;
inline bool MeshInstance::has_transform() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline const ::carto::nml::Matrix4& MeshInstance::transform() const {
  // @@protoc_insertion_point(field_get:carto.nml.MeshInstance.transform)
  return transform_;
}

// -------------------------------------------------------------------

// SubmeshOp

inline SubmeshOp::SubmeshOp() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline SubmeshOp::SubmeshOp(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kSubmeshIdxFieldNumber) {
      submesh_idx_ = msg.read_int32();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kOffsetFieldNumber) {
      offset_ = msg.read_int32();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kCountFieldNumber) {
      count_ = msg.read_int32();
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kTexUScaleFieldNumber) {
      tex_u_scale_ = msg.read_float();
      _has_bits_[0] |= 0x00000008u;
    }
    else if (msg.tag == kTexVScaleFieldNumber) {
      tex_v_scale_ = msg.read_float();
      _has_bits_[0] |= 0x00000010u;
    }
    else if (msg.tag == kTexUTransFieldNumber) {
      tex_u_trans_ = msg.read_float();
      _has_bits_[0] |= 0x00000020u;
    }
    else if (msg.tag == kTexVTransFieldNumber) {
      tex_v_trans_ = msg.read_float();
      _has_bits_[0] |= 0x00000040u;
    }
    else msg.skip();
  }
}

// required int32 submesh_idx = 1;
inline bool SubmeshOp::has_submesh_idx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline std::int32_t SubmeshOp::submesh_idx() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.submesh_idx)
  return submesh_idx_;
}

// required int32 offset = 2;
inline bool SubmeshOp::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline std::int32_t SubmeshOp::offset() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.offset)
  return offset_;
}

// required int32 count = 3;
inline bool SubmeshOp::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline std::int32_t SubmeshOp::count() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.count)
  return count_;
}

// required float tex_u_scale = 4;
inline bool SubmeshOp::has_tex_u_scale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}

inline float SubmeshOp::tex_u_scale() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.tex_u_scale)
  return tex_u_scale_;
}

// required float tex_v_scale = 5;
inline bool SubmeshOp::has_tex_v_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}

inline float SubmeshOp::tex_v_scale() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.tex_v_scale)
  return tex_v_scale_;
}

// required float tex_u_trans = 6;
inline bool SubmeshOp::has_tex_u_trans() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}

inline float SubmeshOp::tex_u_trans() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.tex_u_trans)
  return tex_u_trans_;
}

// required float tex_v_trans = 7;
inline bool SubmeshOp::has_tex_v_trans() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}

inline float SubmeshOp::tex_v_trans() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOp.tex_v_trans)
  return tex_v_trans_;
}

// -------------------------------------------------------------------

// SubmeshOpList

inline SubmeshOpList::SubmeshOpList() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline SubmeshOpList::SubmeshOpList(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kTypeFieldNumber) {
      type_ = msg.read_int32();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kMaterialIdFieldNumber) {
      material_id_ = msg.read_string();
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kSubmeshOpsFieldNumber) {
      submesh_ops_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// required .carto.nml.Submesh.Type type = 1;
inline bool SubmeshOpList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline ::carto::nml::Submesh_Type SubmeshOpList::type() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOpList.type)
  return static_cast< ::carto::nml::Submesh_Type >(type_);
}

// required string material_id = 2;
inline bool SubmeshOpList::has_material_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::std::string& SubmeshOpList::material_id() const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOpList.material_id)
  return material_id_;
}

// repeated .carto.nml.SubmeshOp submesh_ops = 3;
inline int SubmeshOpList::submesh_ops_size() const {
  return static_cast<int>(submesh_ops_.size());
}

inline const ::carto::nml::SubmeshOp& SubmeshOpList::submesh_ops(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.SubmeshOpList.submesh_ops)
  return submesh_ops_[index];
}
inline const std::vector< ::carto::nml::SubmeshOp >& SubmeshOpList::submesh_ops() const {
  // @@protoc_insertion_point(field_list:carto.nml.SubmeshOpList.submesh_ops)
  return submesh_ops_;
}

// -------------------------------------------------------------------

// MeshOp

inline MeshOp::MeshOp() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline MeshOp::MeshOp(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kBoundsFieldNumber) {
      bounds_ = ::carto::nml::Bounds3(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kSubmeshOpListsFieldNumber) {
      submesh_op_lists_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000004u;
    }
    else msg.skip();
  }
}

// required string id = 1;
inline bool MeshOp::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& MeshOp::id() const {
  // @@protoc_insertion_point(field_get:carto.nml.MeshOp.id)
  return id_;
}

// required .carto.nml.Bounds3 bounds = 2;
inline bool MeshOp::has_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::carto::nml::Bounds3& MeshOp::bounds() const {
  // @@protoc_insertion_point(field_get:carto.nml.MeshOp.bounds)
  return bounds_;
}

// repeated .carto.nml.SubmeshOpList submesh_op_lists = 3;
inline int MeshOp::submesh_op_lists_size() const {
  return static_cast<int>(submesh_op_lists_.size());
}

inline const ::carto::nml::SubmeshOpList& MeshOp::submesh_op_lists(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.MeshOp.submesh_op_lists)
  return submesh_op_lists_[index];
}
inline const std::vector< ::carto::nml::SubmeshOpList >& MeshOp::submesh_op_lists() const {
  // @@protoc_insertion_point(field_list:carto.nml.MeshOp.submesh_op_lists)
  return submesh_op_lists_;
}

// -------------------------------------------------------------------

// Model

inline Model::Model() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline Model::Model(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_string();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kMeshInstancesFieldNumber) {
      mesh_instances_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kMeshesFieldNumber) {
      meshes_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kTexturesFieldNumber) {
      textures_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000008u;
    }
    else if (msg.tag == kBoundsFieldNumber) {
      bounds_ = ::carto::nml::Bounds3(msg.read_message());
      _has_bits_[0] |= 0x00000010u;
    }
    else if (msg.tag == kMeshFootprintFieldNumber) {
      mesh_footprint_ = msg.read_int32();
      _has_bits_[0] |= 0x00000020u;
    }
    else if (msg.tag == kTextureFootprintFieldNumber) {
      texture_footprint_ = msg.read_int32();
      _has_bits_[0] |= 0x00000040u;
    }
    else msg.skip();
  }
}

// required string id = 1;
inline bool Model::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline const ::std::string& Model::id() const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.id)
  return id_;
}

// repeated .carto.nml.MeshInstance mesh_instances = 2;
inline int Model::mesh_instances_size() const {
  return static_cast<int>(mesh_instances_.size());
}

inline const ::carto::nml::MeshInstance& Model::mesh_instances(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.mesh_instances)
  return mesh_instances_[index];
}
inline const std::vector< ::carto::nml::MeshInstance >& Model::mesh_instances() const {
  // @@protoc_insertion_point(field_list:carto.nml.Model.mesh_instances)
  return mesh_instances_;
}

// repeated .carto.nml.Mesh meshes = 3;
inline int Model::meshes_size() const {
  return static_cast<int>(meshes_.size());
}

inline const ::carto::nml::Mesh& Model::meshes(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.meshes)
  return meshes_[index];
}
inline const std::vector< ::carto::nml::Mesh >& Model::meshes() const {
  // @@protoc_insertion_point(field_list:carto.nml.Model.meshes)
  return meshes_;
}

// repeated .carto.nml.Texture textures = 4;
inline int Model::textures_size() const {
  return static_cast<int>(textures_.size());
}

inline const ::carto::nml::Texture& Model::textures(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.textures)
  return textures_[index];
}
inline const std::vector< ::carto::nml::Texture >& Model::textures() const {
  // @@protoc_insertion_point(field_list:carto.nml.Model.textures)
  return textures_;
}

// required .carto.nml.Bounds3 bounds = 5;
inline bool Model::has_bounds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}

inline const ::carto::nml::Bounds3& Model::bounds() const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.bounds)
  return bounds_;
}

// required int32 mesh_footprint = 6;
inline bool Model::has_mesh_footprint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}

inline std::int32_t Model::mesh_footprint() const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.mesh_footprint)
  return mesh_footprint_;
}

// required int32 texture_footprint = 7;
inline bool Model::has_texture_footprint() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}

inline std::int32_t Model::texture_footprint() const {
  // @@protoc_insertion_point(field_get:carto.nml.Model.texture_footprint)
  return texture_footprint_;
}

// -------------------------------------------------------------------

// ModelLODTreeNode

inline ModelLODTreeNode::ModelLODTreeNode() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline ModelLODTreeNode::ModelLODTreeNode(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kIdFieldNumber) {
      id_ = msg.read_int32();
      _has_bits_[0] |= 0x00000001u;
    }
    else if (msg.tag == kBoundsFieldNumber) {
      bounds_ = ::carto::nml::Bounds3(msg.read_message());
      _has_bits_[0] |= 0x00000002u;
    }
    else if (msg.tag == kModelFieldNumber) {
      model_ = ::carto::nml::Model(msg.read_message());
      _has_bits_[0] |= 0x00000004u;
    }
    else if (msg.tag == kChildrenIdsFieldNumber) {
      children_ids_.emplace_back(msg.read_int32());
      _has_bits_[0] |= 0x00000008u;
    }
    else msg.skip();
  }
}

// required int32 id = 1;
inline bool ModelLODTreeNode::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}

inline std::int32_t ModelLODTreeNode::id() const {
  // @@protoc_insertion_point(field_get:carto.nml.ModelLODTreeNode.id)
  return id_;
}

// required .carto.nml.Bounds3 bounds = 2;
inline bool ModelLODTreeNode::has_bounds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}

inline const ::carto::nml::Bounds3& ModelLODTreeNode::bounds() const {
  // @@protoc_insertion_point(field_get:carto.nml.ModelLODTreeNode.bounds)
  return bounds_;
}

// required .carto.nml.Model model = 3;
inline bool ModelLODTreeNode::has_model() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}

inline const ::carto::nml::Model& ModelLODTreeNode::model() const {
  // @@protoc_insertion_point(field_get:carto.nml.ModelLODTreeNode.model)
  return model_;
}

// repeated int32 children_ids = 4;
inline int ModelLODTreeNode::children_ids_size() const {
  return static_cast<int>(children_ids_.size());
}

inline std::int32_t ModelLODTreeNode::children_ids(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.ModelLODTreeNode.children_ids)
  return children_ids_[index];
}

inline const std::vector< std::int32_t >& ModelLODTreeNode::children_ids() const {
  // @@protoc_insertion_point(field_list:carto.nml.ModelLODTreeNode.children_ids)
  return children_ids_;
}

// -------------------------------------------------------------------

// ModelLODTree

inline ModelLODTree::ModelLODTree() {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
}

inline ModelLODTree::ModelLODTree(const protobuf::message& srcMsg) {
  std::fill(_has_bits_, _has_bits_ + sizeof(_has_bits_) / sizeof(std::uint32_t), 0);
  for (protobuf::message msg(srcMsg); msg.next(); ) {
    if (msg.tag == kNodesFieldNumber) {
      nodes_.emplace_back(msg.read_message());
      _has_bits_[0] |= 0x00000001u;
    }
    else msg.skip();
  }
}

// repeated .carto.nml.ModelLODTreeNode nodes = 1;
inline int ModelLODTree::nodes_size() const {
  return static_cast<int>(nodes_.size());
}

inline const ::carto::nml::ModelLODTreeNode& ModelLODTree::nodes(int index) const {
  // @@protoc_insertion_point(field_get:carto.nml.ModelLODTree.nodes)
  return nodes_[index];
}
inline const std::vector< ::carto::nml::ModelLODTreeNode >& ModelLODTree::nodes() const {
  // @@protoc_insertion_point(field_list:carto.nml.ModelLODTree.nodes)
  return nodes_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace nml
}  // namespace carto

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_NMLPackage_2eproto__INCLUDED
